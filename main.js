/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var T=Object.defineProperty;var $=Object.getOwnPropertyDescriptor;var A=Object.getOwnPropertyNames;var B=Object.prototype.hasOwnProperty;var E=(d,e)=>{for(var t in e)T(d,t,{get:e[t],enumerable:!0})},M=(d,e,t,n)=>{if(e&&typeof e=="object"||typeof e=="function")for(let o of A(e))!B.call(d,o)&&o!==t&&T(d,o,{get:()=>e[o],enumerable:!(n=$(e,o))||n.enumerable});return d};var V=d=>M(T({},"__esModule",{value:!0}),d);var W={};E(W,{default:()=>w});module.exports=V(W);var P=require("obsidian");var N={inspectedItemTypes:[],nonInspectedItemTypes:[],collections:[]},y=10,I=0,u=10;function v(){return{schemaVersion:1,inspectedItemTypeIds:[],nonInspectedItemTypeIds:[],itemTypes:{},componentIdsByItemType:{},components:{},collectionIds:[],collections:{},items:{}}}function C(d){let e=v();return d.inspectedItemTypes.forEach(t=>{e.inspectedItemTypeIds.push(t.id),e.itemTypes[t.id]={id:t.id,name:t.name,kind:t.kind,inspected:!0},e.componentIdsByItemType[t.id]=[],t.components.forEach(n=>{e.componentIdsByItemType[t.id].push(n.id),e.components[n.id]={id:n.id,itemTypeId:t.id,name:n.name,ratingScale:{min:n.ratingScale.min,max:n.ratingScale.max},weightPercent:n.weightPercent,allowNotInspectedUsePrevious:n.allowNotInspectedUsePrevious}})}),d.nonInspectedItemTypes.forEach(t=>{e.nonInspectedItemTypeIds.push(t.id),e.itemTypes[t.id]={id:t.id,name:t.name,kind:t.kind,inspected:!1}}),d.collections.forEach(t=>{e.collectionIds.push(t.id),e.collections[t.id]={id:t.id,name:t.name,itemIds:[]},t.items.forEach(n=>{e.collections[t.id].itemIds.push(n.id),e.items[n.id]={id:n.id,name:n.name,typeId:n.typeId,station:n.station,startStationItemId:n.startStationItemId,endStationItemId:n.endStationItemId}})}),e}function D(d){let e=d.inspectedItemTypeIds.map(o=>H(d,o)).filter(o=>!!o),t=d.nonInspectedItemTypeIds.map(o=>K(d,o)).filter(o=>!!o),n=d.collectionIds.map(o=>L(d,o)).filter(o=>!!o);return{inspectedItemTypes:e,nonInspectedItemTypes:t,collections:n}}function H(d,e){var a;let t=d.itemTypes[e];if(!t||!t.inspected)return null;let o=((a=d.componentIdsByItemType[e])!=null?a:[]).map(i=>U(d,i,e)).filter(i=>!!i);return{id:t.id,name:t.name,kind:t.kind,components:o}}function K(d,e){let t=d.itemTypes[e];return!t||t.inspected?null:{id:t.id,name:t.name,kind:t.kind}}function U(d,e,t){var o,a;let n=d.components[e];return!n||n.itemTypeId!==t?null:{id:n.id,name:n.name,ratingScale:{min:(o=n.ratingScale.min)!=null?o:I,max:(a=n.ratingScale.max)!=null?a:u},weightPercent:n.weightPercent,allowNotInspectedUsePrevious:n.allowNotInspectedUsePrevious}}function L(d,e){var o;let t=d.collections[e];if(!t)return null;let n=((o=t.itemIds)!=null?o:[]).map(a=>_(d,a)).filter(a=>!!a);return{id:t.id,name:t.name,items:n}}function _(d,e){let t=d.items[e];return t?{id:t.id,name:t.name,typeId:t.typeId,station:t.station,startStationItemId:t.startStationItemId,endStationItemId:t.endStationItemId}:null}function O(d){if(!d||typeof d!="object")return!1;let e=d;return e.schemaVersion===1&&typeof e.database=="object"}var f=class{constructor(e){this.settings={...N};this.database=v();this.plugin=e}async load(){let e=await this.plugin.loadData();if(O(e)){this.database=e.database,this.settings=D(this.database);return}let t=e!=null?e:{};this.settings={...N,...t},this.database=C(this.settings),await this.save()}async saveFromSettings(e){this.settings=e,this.database=C(e),await this.save()}async save(){await this.plugin.saveData({schemaVersion:1,database:this.database})}};var r=require("obsidian");function h(){return typeof crypto!="undefined"&&"randomUUID"in crypto?crypto.randomUUID():`id-${Date.now()}-${Math.random().toString(16).slice(2)}`}function G(d){let e=d.inspectedItemTypes.map(n=>({id:n.id,name:n.name,kind:n.kind})),t=d.nonInspectedItemTypes.map(n=>({id:n.id,name:n.name,kind:n.kind}));return[...e,...t]}function q(d,e){var l,g,b;let t=[],n=d.items.filter(p=>e.get(p.typeId)==="point"),o=new Set(n.map(p=>p.id)),a=new Set,i=new Map;for(let p of d.items)if(e.get(p.typeId)==="linear"){if(!p.startStationItemId||!p.endStationItemId){t.push(`Collection "${d.name}": linear item "${p.name}" must have both a start and end station item.`);continue}if(!o.has(p.startStationItemId)||!o.has(p.endStationItemId)){t.push(`Collection "${d.name}": linear item "${p.name}" must reference point items for start and end.`);continue}a.add(p.startStationItemId),a.add(p.endStationItemId),i.has(p.startStationItemId)||i.set(p.startStationItemId,new Set),i.has(p.endStationItemId)||i.set(p.endStationItemId,new Set),(l=i.get(p.startStationItemId))==null||l.add(p.endStationItemId),(g=i.get(p.endStationItemId))==null||g.add(p.startStationItemId)}if(a.size<=1)return t;let[s]=a;if(!s)return t;let m=new Set,c=[s];for(;c.length>0;){let p=c.shift();if(!p||m.has(p))continue;m.add(p);let R=(b=i.get(p))!=null?b:new Set;for(let k of R)m.has(k)||c.push(k)}return m.size!==a.size&&t.push(`Collection "${d.name}": the linear network is not fully connected. Ensure each linear item connects through stationed point items.`),t}function x(d){let e=[],t=new Set;for(let a of d.inspectedItemTypes){let i=a.name.trim();i||e.push("Inspected item types must have a name."),t.has(i)&&e.push(`Inspected item type name "${i}" is duplicated.`),t.add(i);for(let s of a.components)s.name.trim()||e.push(`Component names for "${a.name}" cannot be empty.`),(s.ratingScale.min<I||s.ratingScale.max>u)&&e.push(`Component "${s.name}" in "${a.name}" must use ratings between ${I} and ${u}.`),s.ratingScale.min>s.ratingScale.max&&e.push(`Component "${s.name}" in "${a.name}" must have a minimum rating less than or equal to the maximum.`),(s.weightPercent<0||s.weightPercent>100)&&e.push(`Component "${s.name}" in "${a.name}" must use a weight between 0 and 100%.`)}let n=new Set;for(let a of d.nonInspectedItemTypes){let i=a.name.trim();i||e.push("Non-inspected item types must have a name."),n.has(i)&&e.push(`Non-inspected item type name "${i}" is duplicated.`),n.add(i)}let o=new Map(G(d).map(a=>[a.id,a.kind]));for(let a of d.collections){let i=new Set;for(let s of a.items){let m=s.name.trim();m||e.push(`Collection "${a.name}": items must have a name.`),i.has(m)&&e.push(`Collection "${a.name}": item name "${m}" is duplicated.`),i.add(m);let c=o.get(s.typeId);c==="point"&&(s.station===void 0||Number.isNaN(s.station))&&e.push(`Collection "${a.name}": point item "${s.name}" must have a station value.`),c==="linear"&&(!s.startStationItemId||!s.endStationItemId)&&e.push(`Collection "${a.name}": linear item "${s.name}" must reference start and end station items.`)}e.push(...q(a,o))}return e}var S=class extends r.PluginSettingTab{constructor(e,t){super(e,t),this.plugin=t}display(){let{containerEl:e}=this;e.empty(),new r.Setting(e).setName("Inspection network").setHeading(),e.createEl("p",{text:"Define the inspection structure here. Start by naming item types, then assemble collections that map your network."}),this.renderSetupOverview(e),this.renderInspectedItemTypes(e),this.renderNonInspectedItemTypes(e),this.renderCollections(e),this.renderValidation(e)}renderSetupOverview(e){new r.Setting(e).setName("Setup checklist").setHeading();let t=e.createEl("ol");t.createEl("li",{text:"Create inspected item types and their rated components."}),t.createEl("li",{text:"Add non-inspected types for markers or reference items (optional)."}),t.createEl("li",{text:"Build collections by adding point items (stations) and linear items (segments)."}),t.createEl("li",{text:"Review validation feedback at the bottom before running inspections."})}renderInspectedItemTypes(e){new r.Setting(e).setName("Inspected item types").setHeading(),e.createEl("p",{text:`Define up to ${y} inspected facility types, each with rated components.`}),e.createEl("p",{text:`Currently using ${this.plugin.settings.inspectedItemTypes.length} of ${y}.`}),new r.Setting(e).setName("Add inspected item type").setDesc("Create a new inspected type for point or linear facilities.").addButton(t=>{t.setButtonText("Add").setDisabled(this.plugin.settings.inspectedItemTypes.length>=y).onClick(async()=>{this.plugin.settings.inspectedItemTypes.push({id:h(),name:"",kind:"point",components:[]}),await this.plugin.saveSettings(),this.display()})}),this.plugin.settings.inspectedItemTypes.forEach((t,n)=>{this.renderInspectedItemType(e,t,n)})}renderInspectedItemType(e,t,n){new r.Setting(e).setName(`Inspected type ${n+1}`).setHeading();let o=e.createEl("p"),a=()=>{let i=t.components.length,s=t.components.reduce((m,c)=>{let l=Number.isFinite(c.weightPercent)?c.weightPercent:0;return m+l},0);o.setText(`Components: ${i}. Total weight: ${s}%.`)};a(),new r.Setting(e).setName("Type name").setDesc("Use a unique name within inspected types.").addText(i=>i.setPlaceholder("Canal check structure").setValue(t.name).onChange(async s=>{t.name=s,await this.plugin.saveSettings()})),new r.Setting(e).setName("Type kind").setDesc("Point items have a single station. Linear items connect two stations.").addDropdown(i=>{i.addOption("point","Point").addOption("linear","Linear").setValue(t.kind).onChange(async s=>{t.kind=s,await this.plugin.saveSettings(),this.display()})}),new r.Setting(e).setName("Remove inspected type").setDesc("Delete this inspected item type and its components.").addButton(i=>i.setButtonText("Remove").setWarning().onClick(async()=>{this.plugin.settings.inspectedItemTypes=this.plugin.settings.inspectedItemTypes.filter(s=>s.id!==t.id),await this.plugin.saveSettings(),this.display()})),new r.Setting(e).setName("Rated components").setHeading(),e.createEl("p",{text:"Each component should have a name, rating scale, and weight that contributes to the total score."}),new r.Setting(e).setName("Add component").setDesc("Add a rated component for this inspected type.").addButton(i=>{i.setButtonText("Add").onClick(async()=>{t.components.push({id:h(),name:"",ratingScale:{min:I,max:u},weightPercent:0,allowNotInspectedUsePrevious:!1}),await this.plugin.saveSettings(),this.display()})}),t.components.forEach(i=>{this.renderComponent(e,t,i,a)})}renderComponent(e,t,n,o){new r.Setting(e).setName("Component name").setDesc("Short label for this rated component.").addText(i=>i.setValue(n.name).onChange(async s=>{n.name=s,await this.plugin.saveSettings()}));let a=new r.Setting(e).setName("Rating scale").setDesc(`Choose a numeric scale between ${I} and ${u}.`);a.addText(i=>{i.setValue(n.ratingScale.min.toString()),i.setPlaceholder("Min"),i.inputEl.type="number",i.inputEl.min=I.toString(),i.inputEl.max=u.toString(),i.onChange(async s=>{n.ratingScale.min=Number(s),await this.plugin.saveSettings()})}),a.addText(i=>{i.setValue(n.ratingScale.max.toString()),i.setPlaceholder("Max"),i.inputEl.type="number",i.inputEl.min=I.toString(),i.inputEl.max=u.toString(),i.onChange(async s=>{n.ratingScale.max=Number(s),await this.plugin.saveSettings()})}),new r.Setting(e).setName("Weight percent").setDesc("Set a weight between 0 and 100. Aim for totals to equal 100%.").addText(i=>{i.setValue(n.weightPercent.toString()),i.inputEl.type="number",i.inputEl.min="0",i.inputEl.max="100",i.onChange(async s=>{n.weightPercent=Number(s),await this.plugin.saveSettings(),o()})}).addButton(i=>i.setButtonText("Remove").setWarning().onClick(async()=>{t.components=t.components.filter(s=>s.id!==n.id),await this.plugin.saveSettings(),this.display()})),new r.Setting(e).setName("Allow not inspected/use previous").setDesc("Enable when the component can be marked not inspected and reuse the previous rating.").addToggle(i=>{i.setValue(n.allowNotInspectedUsePrevious).onChange(async s=>{n.allowNotInspectedUsePrevious=s,await this.plugin.saveSettings()})})}renderNonInspectedItemTypes(e){new r.Setting(e).setName("Non-inspected item types").setHeading(),e.createEl("p",{text:"Define navigation or reference items that are not directly inspected."}),new r.Setting(e).setName("Add non-inspected item type").setDesc("Create a new non-inspected point or linear item type.").addButton(t=>{t.setButtonText("Add").onClick(async()=>{this.plugin.settings.nonInspectedItemTypes.push({id:h(),name:"",kind:"point"}),await this.plugin.saveSettings(),this.display()})}),this.plugin.settings.nonInspectedItemTypes.forEach((t,n)=>{this.renderNonInspectedItemType(e,t,n)})}renderNonInspectedItemType(e,t,n){new r.Setting(e).setName(`Non-inspected type ${n+1}`).setHeading(),new r.Setting(e).setName("Type name").setDesc("Use a unique name within non-inspected types.").addText(o=>o.setPlaceholder("Station marker").setValue(t.name).onChange(async a=>{t.name=a,await this.plugin.saveSettings()})),new r.Setting(e).setName("Type kind").setDesc("Point items have a single station. Linear items connect two stations.").addDropdown(o=>{o.addOption("point","Point").addOption("linear","Linear").setValue(t.kind).onChange(async a=>{t.kind=a,await this.plugin.saveSettings(),this.display()})}),new r.Setting(e).setName("Remove non-inspected type").setDesc("Delete this non-inspected item type.").addButton(o=>o.setButtonText("Remove").setWarning().onClick(async()=>{this.plugin.settings.nonInspectedItemTypes=this.plugin.settings.nonInspectedItemTypes.filter(a=>a.id!==t.id),await this.plugin.saveSettings(),this.display()}))}renderCollections(e){new r.Setting(e).setName("Collections").setHeading(),e.createEl("p",{text:"Define each connected linear network (for example, a single canal)."}),e.createEl("p",{text:"Tip: add point items first so linear items can reference start and end stations."}),new r.Setting(e).setName("Add collection").setDesc("Create a named collection of inspected and reference items.").addButton(t=>{t.setButtonText("Add").onClick(async()=>{this.plugin.settings.collections.push({id:h(),name:"",items:[]}),await this.plugin.saveSettings(),this.display()})}),this.plugin.settings.collections.forEach((t,n)=>{this.renderCollection(e,t,n)})}renderCollection(e,t,n){if(new r.Setting(e).setName(`Collection ${n+1}`).setHeading(),new r.Setting(e).setName("Collection name").setDesc("Names are used to group items into connected networks.").addText(o=>o.setPlaceholder("Example canal").setValue(t.name).onChange(async a=>{t.name=a,await this.plugin.saveSettings()})),new r.Setting(e).setName("Remove collection").setDesc("Delete this collection and its items.").addButton(o=>o.setButtonText("Remove").setWarning().onClick(async()=>{this.plugin.settings.collections=this.plugin.settings.collections.filter(a=>a.id!==t.id),await this.plugin.saveSettings(),this.display()})),new r.Setting(e).setName("Add item").setDesc("Add an inspected or reference item to this collection.").addButton(o=>{o.setButtonText("Add").onClick(async()=>{let i=this.getItemTypeSummaries()[0],s=i?i.id:"";t.items.push({id:h(),name:"",typeId:s,station:void 0}),await this.plugin.saveSettings(),this.display()})}),t.items.length===0){e.createEl("p",{text:"No items yet. Add an item to begin describing stations and segments."});return}t.items.forEach((o,a)=>{this.renderCollectionItem(e,t,o,a)})}renderCollectionItem(e,t,n,o){new r.Setting(e).setName(`Item ${o+1}`).setHeading(),new r.Setting(e).setName("Item name").setDesc("Item names must be unique within a collection.").addText(i=>i.setPlaceholder("Reach 1").setValue(n.name).onChange(async s=>{n.name=s,await this.plugin.saveSettings()})),new r.Setting(e).setName("Item type").setDesc("Choose the inspected or non-inspected type for this item.").addDropdown(i=>{var m;let s=this.getItemTypeSummaries();if(s.length===0){i.addOption("","Add item types first"),i.setValue(""),i.setDisabled(!0);return}s.forEach(c=>{i.addOption(c.id,`${c.name||"(unnamed)"} (${c.kind})`)}),i.setValue(n.typeId||((m=s[0])==null?void 0:m.id)||""),i.onChange(async c=>{n.typeId=c;let l=this.getItemKind(c);l==="point"?(n.startStationItemId=void 0,n.endStationItemId=void 0):l==="linear"&&(n.station=void 0),await this.plugin.saveSettings(),this.display()})});let a=this.getItemKind(n.typeId);if(a==="point"&&new r.Setting(e).setName("Station").setDesc("Station value for this point item.").addText(i=>{var s,m;i.setValue((m=(s=n.station)==null?void 0:s.toString())!=null?m:""),i.setPlaceholder("0.0"),i.inputEl.type="number",i.onChange(async c=>{n.station=c===""?void 0:Number(c),await this.plugin.saveSettings()})}),a==="linear"){let i=t.items.filter(m=>this.getItemKind(m.typeId)==="point");e.createEl("p",{text:`Available point items: ${i.length}.`});let s=i.map(m=>({id:m.id,label:`${m.name||"(unnamed)"} ${m.station!==void 0?`@ ${m.station}`:"(no station)"}`}));new r.Setting(e).setName("Start station item").setDesc("Select the point item that defines the start station.").addDropdown(m=>{var c,l;if(s.length===0){m.addOption("","Add a point item first"),m.setValue(""),m.setDisabled(!0);return}s.forEach(g=>m.addOption(g.id,g.label)),m.setValue(n.startStationItemId||((l=(c=s[0])==null?void 0:c.id)!=null?l:"")).onChange(async g=>{n.startStationItemId=g,await this.plugin.saveSettings()})}),new r.Setting(e).setName("End station item").setDesc("Select the point item that defines the end station.").addDropdown(m=>{var c,l;if(s.length===0){m.addOption("","Add a point item first"),m.setValue(""),m.setDisabled(!0);return}s.forEach(g=>m.addOption(g.id,g.label)),m.setValue(n.endStationItemId||((l=(c=s[0])==null?void 0:c.id)!=null?l:"")).onChange(async g=>{n.endStationItemId=g,await this.plugin.saveSettings()})})}new r.Setting(e).setName("Remove item").setDesc("Delete this item from the collection.").addButton(i=>i.setButtonText("Remove").setWarning().onClick(async()=>{t.items=t.items.filter(s=>s.id!==n.id),await this.plugin.saveSettings(),this.display()}))}renderValidation(e){let t=x(this.plugin.settings);if(new r.Setting(e).setName("Validation").setHeading(),e.createEl("p",{text:"Resolve any issues below to keep inspections consistent and connected."}),t.length===0){e.createEl("p",{text:"All settings are valid."});return}let n=e.createEl("ul");t.forEach(o=>{n.createEl("li",{text:o})})}getItemTypeSummaries(){let e=this.plugin.settings.inspectedItemTypes.map(n=>({id:n.id,name:n.name,kind:n.kind})),t=this.plugin.settings.nonInspectedItemTypes.map(n=>({id:n.id,name:n.name,kind:n.kind}));return[...e,...t]}getItemKind(e){let t=this.getItemTypeSummaries().find(n=>n.id===e);return t==null?void 0:t.kind}};var w=class extends P.Plugin{async onload(){await this.loadSettings(),this.addSettingTab(new S(this.app,this))}async loadSettings(){this.store=new f(this),await this.store.load(),this.settings=this.store.settings}async saveSettings(){await this.store.saveFromSettings(this.settings)}};
