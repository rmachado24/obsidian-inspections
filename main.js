/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var w=Object.defineProperty;var A=Object.getOwnPropertyDescriptor;var $=Object.getOwnPropertyNames;var B=Object.prototype.hasOwnProperty;var V=(o,e)=>{for(var t in e)w(o,t,{get:e[t],enumerable:!0})},M=(o,e,t,n)=>{if(e&&typeof e=="object"||typeof e=="function")for(let s of $(e))!B.call(o,s)&&s!==t&&w(o,s,{get:()=>e[s],enumerable:!(n=A(e,s))||n.enumerable});return o};var E=o=>M(w({},"__esModule",{value:!0}),o);var X={};V(X,{default:()=>S});module.exports=E(X);var R=require("obsidian");var T={inspectedItemTypes:[],nonInspectedItemTypes:[],collections:[]},b=10,g=0,u=10;function N(){return{schemaVersion:1,inspectedItemTypeIds:[],nonInspectedItemTypeIds:[],itemTypes:{},componentIdsByItemType:{},components:{},collectionIds:[],collections:{},items:{}}}function v(o){let e=N();return o.inspectedItemTypes.forEach(t=>{e.inspectedItemTypeIds.push(t.id),e.itemTypes[t.id]={id:t.id,name:t.name,kind:t.kind,inspected:!0},e.componentIdsByItemType[t.id]=[],t.components.forEach(n=>{e.componentIdsByItemType[t.id].push(n.id),e.components[n.id]={id:n.id,itemTypeId:t.id,name:n.name,ratingScale:{min:n.ratingScale.min,max:n.ratingScale.max},weightPercent:n.weightPercent,allowNotInspectedUsePrevious:n.allowNotInspectedUsePrevious}})}),o.nonInspectedItemTypes.forEach(t=>{e.nonInspectedItemTypeIds.push(t.id),e.itemTypes[t.id]={id:t.id,name:t.name,kind:t.kind,inspected:!1}}),o.collections.forEach(t=>{e.collectionIds.push(t.id),e.collections[t.id]={id:t.id,name:t.name,itemIds:[]},t.items.forEach(n=>{e.collections[t.id].itemIds.push(n.id),e.items[n.id]={id:n.id,name:n.name,typeId:n.typeId,station:n.station,startStationItemId:n.startStationItemId,endStationItemId:n.endStationItemId}})}),e}function D(o){let e=o.inspectedItemTypeIds.map(s=>H(o,s)).filter(s=>!!s),t=o.nonInspectedItemTypeIds.map(s=>K(o,s)).filter(s=>!!s),n=o.collectionIds.map(s=>L(o,s)).filter(s=>!!s);return{inspectedItemTypes:e,nonInspectedItemTypes:t,collections:n}}function H(o,e){var i;let t=o.itemTypes[e];if(!t||!t.inspected)return null;let s=((i=o.componentIdsByItemType[e])!=null?i:[]).map(a=>U(o,a,e)).filter(a=>!!a);return{id:t.id,name:t.name,kind:t.kind,components:s}}function K(o,e){let t=o.itemTypes[e];return!t||t.inspected?null:{id:t.id,name:t.name,kind:t.kind}}function U(o,e,t){var s,i;let n=o.components[e];return!n||n.itemTypeId!==t?null:{id:n.id,name:n.name,ratingScale:{min:(s=n.ratingScale.min)!=null?s:g,max:(i=n.ratingScale.max)!=null?i:u},weightPercent:n.weightPercent,allowNotInspectedUsePrevious:n.allowNotInspectedUsePrevious}}function L(o,e){var s;let t=o.collections[e];if(!t)return null;let n=((s=t.itemIds)!=null?s:[]).map(i=>_(o,i)).filter(i=>!!i);return{id:t.id,name:t.name,items:n}}function _(o,e){let t=o.items[e];return t?{id:t.id,name:t.name,typeId:t.typeId,station:t.station,startStationItemId:t.startStationItemId,endStationItemId:t.endStationItemId}:null}function G(o){if(!o||typeof o!="object")return!1;let e=o;return e.schemaVersion===1&&typeof e.database=="object"}var f=class{constructor(e){this.settings={...T};this.database=N();this.plugin=e}async load(){let e=await this.plugin.loadData();if(G(e)){this.database=e.database,this.settings=D(this.database);return}let t=e!=null?e:{};this.settings={...T,...t},this.database=v(this.settings),await this.save()}async saveFromSettings(e){this.settings=e,this.database=v(e),await this.save()}async save(){await this.plugin.saveData({schemaVersion:1,database:this.database})}};var m=require("obsidian");function h(){return typeof crypto!="undefined"&&"randomUUID"in crypto?crypto.randomUUID():`id-${Date.now()}-${Math.random().toString(16).slice(2)}`}function O(o){let e=o.inspectedItemTypes.map(n=>({id:n.id,name:n.name,kind:n.kind})),t=o.nonInspectedItemTypes.map(n=>({id:n.id,name:n.name,kind:n.kind}));return[...e,...t]}function W(o,e){var I,l,C;let t=[],n=o.items.filter(p=>e.get(p.typeId)==="point"),s=new Set(n.map(p=>p.id)),i=new Set,a=new Map;for(let p of o.items)if(e.get(p.typeId)==="linear"){if(!p.startStationItemId||!p.endStationItemId){t.push(`Collection "${o.name}": linear item "${p.name}" must have both a start and end station item.`);continue}if(!s.has(p.startStationItemId)||!s.has(p.endStationItemId)){t.push(`Collection "${o.name}": linear item "${p.name}" must reference point items for start and end.`);continue}i.add(p.startStationItemId),i.add(p.endStationItemId),a.has(p.startStationItemId)||a.set(p.startStationItemId,new Set),a.has(p.endStationItemId)||a.set(p.endStationItemId,new Set),(I=a.get(p.startStationItemId))==null||I.add(p.endStationItemId),(l=a.get(p.endStationItemId))==null||l.add(p.startStationItemId)}if(i.size<=1)return t;let[d]=i;if(!d)return t;let r=new Set,c=[d];for(;c.length>0;){let p=c.shift();if(!p||r.has(p))continue;r.add(p);let P=(C=a.get(p))!=null?C:new Set;for(let k of P)r.has(k)||c.push(k)}return r.size!==i.size&&t.push(`Collection "${o.name}": the linear network is not fully connected. Ensure each linear item connects through stationed point items.`),t}function x(o){let e=[],t=new Set;for(let i of o.inspectedItemTypes){let a=i.name.trim();a||e.push("Inspected item types must have a name."),t.has(a)&&e.push(`Inspected item type name "${a}" is duplicated.`),t.add(a);for(let d of i.components)d.name.trim()||e.push(`Component names for "${i.name}" cannot be empty.`),(d.ratingScale.min<g||d.ratingScale.max>u)&&e.push(`Component "${d.name}" in "${i.name}" must use ratings between ${g} and ${u}.`),d.ratingScale.min>d.ratingScale.max&&e.push(`Component "${d.name}" in "${i.name}" must have a minimum rating less than or equal to the maximum.`),(d.weightPercent<0||d.weightPercent>100)&&e.push(`Component "${d.name}" in "${i.name}" must use a weight between 0 and 100%.`)}let n=new Set;for(let i of o.nonInspectedItemTypes){let a=i.name.trim();a||e.push("Non-inspected item types must have a name."),n.has(a)&&e.push(`Non-inspected item type name "${a}" is duplicated.`),n.add(a)}let s=new Map(O(o).map(i=>[i.id,i.kind]));for(let i of o.collections){let a=new Set;for(let d of i.items){let r=d.name.trim();r||e.push(`Collection "${i.name}": items must have a name.`),a.has(r)&&e.push(`Collection "${i.name}": item name "${r}" is duplicated.`),a.add(r);let c=s.get(d.typeId);c==="point"&&(d.station===void 0||Number.isNaN(d.station))&&e.push(`Collection "${i.name}": point item "${d.name}" must have a station value.`),c==="linear"&&(!d.startStationItemId||!d.endStationItemId)&&e.push(`Collection "${i.name}": linear item "${d.name}" must reference start and end station items.`)}e.push(...W(i,s))}return e}var y=class extends m.PluginSettingTab{constructor(e,t){super(e,t),this.plugin=t}display(){let{containerEl:e}=this;e.empty(),new m.Setting(e).setName("Inspection network").setHeading(),this.renderInspectedItemTypes(e),this.renderNonInspectedItemTypes(e),this.renderCollections(e),this.renderValidation(e)}renderInspectedItemTypes(e){new m.Setting(e).setName("Inspected item types").setHeading(),e.createEl("p",{text:"Define up to 10 inspected facility types, each with rated components."}),new m.Setting(e).setName("Add inspected item type").setDesc("Create a new inspected type for point or linear facilities.").addButton(t=>{t.setButtonText("Add").setDisabled(this.plugin.settings.inspectedItemTypes.length>=b).onClick(async()=>{this.plugin.settings.inspectedItemTypes.push({id:h(),name:"",kind:"point",components:[]}),await this.plugin.saveSettings(),this.display()})}),this.plugin.settings.inspectedItemTypes.forEach((t,n)=>{this.renderInspectedItemType(e,t,n)})}renderInspectedItemType(e,t,n){new m.Setting(e).setName(`Inspected type ${n+1}`).setHeading(),new m.Setting(e).setName("Type name").setDesc("Use a unique name within inspected types.").addText(s=>s.setPlaceholder("Canal check structure").setValue(t.name).onChange(async i=>{t.name=i,await this.plugin.saveSettings()})),new m.Setting(e).setName("Type kind").setDesc("Point items have a single station. Linear items connect two stations.").addDropdown(s=>{s.addOption("point","Point").addOption("linear","Linear").setValue(t.kind).onChange(async i=>{t.kind=i,await this.plugin.saveSettings(),this.display()})}),new m.Setting(e).setName("Remove inspected type").setDesc("Delete this inspected item type.").addButton(s=>s.setButtonText("Remove").setWarning().onClick(async()=>{this.plugin.settings.inspectedItemTypes=this.plugin.settings.inspectedItemTypes.filter(i=>i.id!==t.id),await this.plugin.saveSettings(),this.display()})),new m.Setting(e).setName("Rated components").setHeading(),new m.Setting(e).setName("Add component").setDesc("Add a rated component for this inspected type.").addButton(s=>{s.setButtonText("Add").onClick(async()=>{t.components.push({id:h(),name:"",ratingScale:{min:g,max:u},weightPercent:0,allowNotInspectedUsePrevious:!1}),await this.plugin.saveSettings(),this.display()})}),t.components.forEach(s=>{this.renderComponent(e,t,s)})}renderComponent(e,t,n){new m.Setting(e).setName("Component name").setDesc("Short label for this rated component.").addText(i=>i.setValue(n.name).onChange(async a=>{n.name=a,await this.plugin.saveSettings()}));let s=new m.Setting(e).setName("Rating scale").setDesc(`Choose a numeric scale between ${g} and ${u}.`);s.addText(i=>{i.setValue(n.ratingScale.min.toString()),i.inputEl.type="number",i.inputEl.min=g.toString(),i.inputEl.max=u.toString(),i.onChange(async a=>{n.ratingScale.min=Number(a),await this.plugin.saveSettings()})}),s.addText(i=>{i.setValue(n.ratingScale.max.toString()),i.inputEl.type="number",i.inputEl.min=g.toString(),i.inputEl.max=u.toString(),i.onChange(async a=>{n.ratingScale.max=Number(a),await this.plugin.saveSettings()})}),new m.Setting(e).setName("Weight percent").setDesc("Set a universal weight for this component.").addText(i=>{i.setValue(n.weightPercent.toString()),i.inputEl.type="number",i.inputEl.min="0",i.inputEl.max="100",i.onChange(async a=>{n.weightPercent=Number(a),await this.plugin.saveSettings()})}).addButton(i=>i.setButtonText("Remove").setWarning().onClick(async()=>{t.components=t.components.filter(a=>a.id!==n.id),await this.plugin.saveSettings(),this.display()})),new m.Setting(e).setName("Allow not inspected/use previous").setDesc("Enable when the component can be marked not inspected and reuse the previous rating.").addToggle(i=>{i.setValue(n.allowNotInspectedUsePrevious).onChange(async a=>{n.allowNotInspectedUsePrevious=a,await this.plugin.saveSettings()})})}renderNonInspectedItemTypes(e){new m.Setting(e).setName("Non-inspected item types").setHeading(),e.createEl("p",{text:"Define navigation or reference items that are not directly inspected."}),new m.Setting(e).setName("Add non-inspected item type").setDesc("Create a new non-inspected point or linear item type.").addButton(t=>{t.setButtonText("Add").onClick(async()=>{this.plugin.settings.nonInspectedItemTypes.push({id:h(),name:"",kind:"point"}),await this.plugin.saveSettings(),this.display()})}),this.plugin.settings.nonInspectedItemTypes.forEach((t,n)=>{this.renderNonInspectedItemType(e,t,n)})}renderNonInspectedItemType(e,t,n){new m.Setting(e).setName(`Non-inspected type ${n+1}`).setHeading(),new m.Setting(e).setName("Type name").setDesc("Use a unique name within non-inspected types.").addText(s=>s.setPlaceholder("Station marker").setValue(t.name).onChange(async i=>{t.name=i,await this.plugin.saveSettings()})),new m.Setting(e).setName("Type kind").setDesc("Point items have a single station. Linear items connect two stations.").addDropdown(s=>{s.addOption("point","Point").addOption("linear","Linear").setValue(t.kind).onChange(async i=>{t.kind=i,await this.plugin.saveSettings(),this.display()})}),new m.Setting(e).setName("Remove non-inspected type").setDesc("Delete this non-inspected item type.").addButton(s=>s.setButtonText("Remove").setWarning().onClick(async()=>{this.plugin.settings.nonInspectedItemTypes=this.plugin.settings.nonInspectedItemTypes.filter(i=>i.id!==t.id),await this.plugin.saveSettings(),this.display()}))}renderCollections(e){new m.Setting(e).setName("Collections").setHeading(),e.createEl("p",{text:"Define each connected linear network (for example, a single canal)."}),new m.Setting(e).setName("Add collection").setDesc("Create a named collection of inspected and reference items.").addButton(t=>{t.setButtonText("Add").onClick(async()=>{this.plugin.settings.collections.push({id:h(),name:"",items:[]}),await this.plugin.saveSettings(),this.display()})}),this.plugin.settings.collections.forEach((t,n)=>{this.renderCollection(e,t,n)})}renderCollection(e,t,n){if(new m.Setting(e).setName(`Collection ${n+1}`).setHeading(),new m.Setting(e).setName("Collection name").setDesc("Names are used to group items into connected networks.").addText(s=>s.setPlaceholder("Example canal").setValue(t.name).onChange(async i=>{t.name=i,await this.plugin.saveSettings()})),new m.Setting(e).setName("Remove collection").setDesc("Delete this collection and its items.").addButton(s=>s.setButtonText("Remove").setWarning().onClick(async()=>{this.plugin.settings.collections=this.plugin.settings.collections.filter(i=>i.id!==t.id),await this.plugin.saveSettings(),this.display()})),new m.Setting(e).setName("Add item").setDesc("Add an inspected or reference item to this collection.").addButton(s=>{s.setButtonText("Add").onClick(async()=>{let a=this.getItemTypeSummaries()[0],d=a?a.id:"";t.items.push({id:h(),name:"",typeId:d,station:void 0}),await this.plugin.saveSettings(),this.display()})}),t.items.length===0){e.createEl("p",{text:"No items yet. Add an item to begin describing stations and segments."});return}t.items.forEach((s,i)=>{this.renderCollectionItem(e,t,s,i)})}renderCollectionItem(e,t,n,s){new m.Setting(e).setName(`Item ${s+1}`).setHeading(),new m.Setting(e).setName("Item name").setDesc("Item names must be unique within a collection.").addText(a=>a.setPlaceholder("Reach 1").setValue(n.name).onChange(async d=>{n.name=d,await this.plugin.saveSettings()})),new m.Setting(e).setName("Item type").setDesc("Choose the inspected or non-inspected type for this item.").addDropdown(a=>{var r;let d=this.getItemTypeSummaries();if(d.length===0){a.addOption("","Add item types first"),a.setValue(""),a.setDisabled(!0);return}d.forEach(c=>{a.addOption(c.id,`${c.name||"(unnamed)"} (${c.kind})`)}),a.setValue(n.typeId||((r=d[0])==null?void 0:r.id)||""),a.onChange(async c=>{n.typeId=c;let I=this.getItemKind(c);I==="point"?(n.startStationItemId=void 0,n.endStationItemId=void 0):I==="linear"&&(n.station=void 0),await this.plugin.saveSettings(),this.display()})});let i=this.getItemKind(n.typeId);if(i==="point"&&new m.Setting(e).setName("Station").setDesc("Station value for this point item.").addText(a=>{var d,r;a.setValue((r=(d=n.station)==null?void 0:d.toString())!=null?r:""),a.inputEl.type="number",a.onChange(async c=>{n.station=c===""?void 0:Number(c),await this.plugin.saveSettings()})}),i==="linear"){let d=t.items.filter(r=>this.getItemKind(r.typeId)==="point").map(r=>({id:r.id,label:`${r.name||"(unnamed)"} ${r.station!==void 0?`@ ${r.station}`:"(no station)"}`}));new m.Setting(e).setName("Start station item").setDesc("Select the point item that defines the start station.").addDropdown(r=>{var c,I;if(d.length===0){r.addOption("","Add a point item first"),r.setValue(""),r.setDisabled(!0);return}d.forEach(l=>r.addOption(l.id,l.label)),r.setValue(n.startStationItemId||((I=(c=d[0])==null?void 0:c.id)!=null?I:"")).onChange(async l=>{n.startStationItemId=l,await this.plugin.saveSettings()})}),new m.Setting(e).setName("End station item").setDesc("Select the point item that defines the end station.").addDropdown(r=>{var c,I;if(d.length===0){r.addOption("","Add a point item first"),r.setValue(""),r.setDisabled(!0);return}d.forEach(l=>r.addOption(l.id,l.label)),r.setValue(n.endStationItemId||((I=(c=d[0])==null?void 0:c.id)!=null?I:"")).onChange(async l=>{n.endStationItemId=l,await this.plugin.saveSettings()})})}new m.Setting(e).setName("Remove item").setDesc("Delete this item from the collection.").addButton(a=>a.setButtonText("Remove").setWarning().onClick(async()=>{t.items=t.items.filter(d=>d.id!==n.id),await this.plugin.saveSettings(),this.display()}))}renderValidation(e){let t=x(this.plugin.settings);if(new m.Setting(e).setName("Validation").setHeading(),t.length===0){e.createEl("p",{text:"All settings are valid."});return}let n=e.createEl("ul");t.forEach(s=>{n.createEl("li",{text:s})})}getItemTypeSummaries(){let e=this.plugin.settings.inspectedItemTypes.map(n=>({id:n.id,name:n.name,kind:n.kind})),t=this.plugin.settings.nonInspectedItemTypes.map(n=>({id:n.id,name:n.name,kind:n.kind}));return[...e,...t]}getItemKind(e){let t=this.getItemTypeSummaries().find(n=>n.id===e);return t==null?void 0:t.kind}};var S=class extends R.Plugin{async onload(){await this.loadSettings(),this.addSettingTab(new y(this.app,this))}async loadSettings(){this.store=new f(this),await this.store.load(),this.settings=this.store.settings}async saveSettings(){await this.store.saveFromSettings(this.settings)}};
var w=Object.defineProperty;var x=Object.getOwnPropertyDescriptor;var D=Object.getOwnPropertyNames;var $=Object.prototype.hasOwnProperty;var A=(c,e)=>{for(var n in e)w(c,n,{get:e[n],enumerable:!0})},P=(c,e,n,i)=>{if(e&&typeof e=="object"||typeof e=="function")for(let m of D(e))!$.call(c,m)&&m!==n&&w(c,m,{get:()=>e[m],enumerable:!(i=x(e,m))||i.enumerable});return c};var M=c=>P(w({},"__esModule",{value:!0}),c);var B={};A(B,{default:()=>S});module.exports=M(B);var k=require("obsidian");var v={inspectedItemTypes:[],nonInspectedItemTypes:[],collections:[]},f=10,u=0,h=10;var o=require("obsidian");function I(){return typeof crypto!="undefined"&&"randomUUID"in crypto?crypto.randomUUID():`id-${Date.now()}-${Math.random().toString(16).slice(2)}`}function R(c){let e=c.inspectedItemTypes.map(i=>({id:i.id,name:i.name,kind:i.kind})),n=c.nonInspectedItemTypes.map(i=>({id:i.id,name:i.name,kind:i.kind}));return[...e,...n]}function E(c,e){var l,g,T;let n=[],i=c.items.filter(r=>e.get(r.typeId)==="point"),m=new Set(i.map(r=>r.id)),a=new Set,t=new Map;for(let r of c.items)if(e.get(r.typeId)==="linear"){if(!r.startStationItemId||!r.endStationItemId){n.push(`Collection "${c.name}": linear item "${r.name}" must have both a start and end station item.`);continue}if(!m.has(r.startStationItemId)||!m.has(r.endStationItemId)){n.push(`Collection "${c.name}": linear item "${r.name}" must reference point items for start and end.`);continue}a.add(r.startStationItemId),a.add(r.endStationItemId),t.has(r.startStationItemId)||t.set(r.startStationItemId,new Set),t.has(r.endStationItemId)||t.set(r.endStationItemId,new Set),(l=t.get(r.startStationItemId))==null||l.add(r.endStationItemId),(g=t.get(r.endStationItemId))==null||g.add(r.startStationItemId)}if(a.size<=1)return n;let[s]=a;if(!s)return n;let d=new Set,p=[s];for(;p.length>0;){let r=p.shift();if(!r||d.has(r))continue;d.add(r);let b=(T=t.get(r))!=null?T:new Set;for(let N of b)d.has(N)||p.push(N)}return d.size!==a.size&&n.push(`Collection "${c.name}": the linear network is not fully connected. Ensure each linear item connects through stationed point items.`),n}function C(c){let e=[],n=new Set;for(let a of c.inspectedItemTypes){let t=a.name.trim();t||e.push("Inspected item types must have a name."),n.has(t)&&e.push(`Inspected item type name "${t}" is duplicated.`),n.add(t);for(let s of a.components)s.name.trim()||e.push(`Component names for "${a.name}" cannot be empty.`),(s.ratingScale.min<u||s.ratingScale.max>h)&&e.push(`Component "${s.name}" in "${a.name}" must use ratings between ${u} and ${h}.`),s.ratingScale.min>s.ratingScale.max&&e.push(`Component "${s.name}" in "${a.name}" must have a minimum rating less than or equal to the maximum.`),(s.weightPercent<0||s.weightPercent>100)&&e.push(`Component "${s.name}" in "${a.name}" must use a weight between 0 and 100%.`)}let i=new Set;for(let a of c.nonInspectedItemTypes){let t=a.name.trim();t||e.push("Non-inspected item types must have a name."),i.has(t)&&e.push(`Non-inspected item type name "${t}" is duplicated.`),i.add(t)}let m=new Map(R(c).map(a=>[a.id,a.kind]));for(let a of c.collections){let t=new Set;for(let s of a.items){let d=s.name.trim();d||e.push(`Collection "${a.name}": items must have a name.`),t.has(d)&&e.push(`Collection "${a.name}": item name "${d}" is duplicated.`),t.add(d);let p=m.get(s.typeId);p==="point"&&(s.station===void 0||Number.isNaN(s.station))&&e.push(`Collection "${a.name}": point item "${s.name}" must have a station value.`),p==="linear"&&(!s.startStationItemId||!s.endStationItemId)&&e.push(`Collection "${a.name}": linear item "${s.name}" must reference start and end station items.`)}e.push(...E(a,m))}return e}var y=class extends o.PluginSettingTab{constructor(e,n){super(e,n),this.plugin=n}display(){let{containerEl:e}=this;e.empty(),new o.Setting(e).setName("Inspection network").setHeading(),e.createEl("p",{text:"Define the inspection structure here. Start by naming item types, then assemble collections that map your network."}),this.renderSetupOverview(e),this.renderInspectedItemTypes(e),this.renderNonInspectedItemTypes(e),this.renderCollections(e),this.renderValidation(e)}renderSetupOverview(e){new o.Setting(e).setName("Setup checklist").setHeading();let n=e.createEl("ol");n.createEl("li",{text:"Create inspected item types and their rated components."}),n.createEl("li",{text:"Add non-inspected types for markers or reference items (optional)."}),n.createEl("li",{text:"Build collections by adding point items (stations) and linear items (segments)."}),n.createEl("li",{text:"Review validation feedback at the bottom before running inspections."})}renderInspectedItemTypes(e){new o.Setting(e).setName("Inspected item types").setHeading(),e.createEl("p",{text:`Define up to ${f} inspected facility types, each with rated components.`}),e.createEl("p",{text:`Currently using ${this.plugin.settings.inspectedItemTypes.length} of ${f}.`}),new o.Setting(e).setName("Add inspected item type").setDesc("Create a new inspected type for point or linear facilities.").addButton(n=>{n.setButtonText("Add").setDisabled(this.plugin.settings.inspectedItemTypes.length>=f).onClick(async()=>{this.plugin.settings.inspectedItemTypes.push({id:I(),name:"",kind:"point",components:[]}),await this.plugin.saveSettings(),this.display()})}),this.plugin.settings.inspectedItemTypes.forEach((n,i)=>{this.renderInspectedItemType(e,n,i)})}renderInspectedItemType(e,n,i){new o.Setting(e).setName(`Inspected type ${i+1}`).setHeading();let m=e.createEl("p"),a=()=>{let t=n.components.length,s=n.components.reduce((d,p)=>{let l=Number.isFinite(p.weightPercent)?p.weightPercent:0;return d+l},0);m.setText(`Components: ${t}. Total weight: ${s}%.`)};a(),new o.Setting(e).setName("Type name").setDesc("Use a unique name within inspected types.").addText(t=>t.setPlaceholder("Canal check structure").setValue(n.name).onChange(async s=>{n.name=s,await this.plugin.saveSettings()})),new o.Setting(e).setName("Type kind").setDesc("Point items have a single station. Linear items connect two stations.").addDropdown(t=>{t.addOption("point","Point").addOption("linear","Linear").setValue(n.kind).onChange(async s=>{n.kind=s,await this.plugin.saveSettings(),this.display()})}),new o.Setting(e).setName("Remove inspected type").setDesc("Delete this inspected item type and its components.").addButton(t=>t.setButtonText("Remove").setWarning().onClick(async()=>{this.plugin.settings.inspectedItemTypes=this.plugin.settings.inspectedItemTypes.filter(s=>s.id!==n.id),await this.plugin.saveSettings(),this.display()})),new o.Setting(e).setName("Rated components").setHeading(),e.createEl("p",{text:"Each component should have a name, rating scale, and weight that contributes to the total score."}),new o.Setting(e).setName("Add component").setDesc("Add a rated component for this inspected type.").addButton(t=>{t.setButtonText("Add").onClick(async()=>{n.components.push({id:I(),name:"",ratingScale:{min:u,max:h},weightPercent:0,allowNotInspectedUsePrevious:!1}),await this.plugin.saveSettings(),this.display()})}),n.components.forEach(t=>{this.renderComponent(e,n,t,a)})}renderComponent(e,n,i,m){new o.Setting(e).setName("Component name").setDesc("Short label for this rated component.").addText(t=>t.setValue(i.name).onChange(async s=>{i.name=s,await this.plugin.saveSettings()}));let a=new o.Setting(e).setName("Rating scale").setDesc(`Choose a numeric scale between ${u} and ${h}.`);a.addText(t=>{t.setValue(i.ratingScale.min.toString()),t.setPlaceholder("Min"),t.inputEl.type="number",t.inputEl.min=u.toString(),t.inputEl.max=h.toString(),t.onChange(async s=>{i.ratingScale.min=Number(s),await this.plugin.saveSettings()})}),a.addText(t=>{t.setValue(i.ratingScale.max.toString()),t.setPlaceholder("Max"),t.inputEl.type="number",t.inputEl.min=u.toString(),t.inputEl.max=h.toString(),t.onChange(async s=>{i.ratingScale.max=Number(s),await this.plugin.saveSettings()})}),new o.Setting(e).setName("Weight percent").setDesc("Set a weight between 0 and 100. Aim for totals to equal 100%.").addText(t=>{t.setValue(i.weightPercent.toString()),t.inputEl.type="number",t.inputEl.min="0",t.inputEl.max="100",t.onChange(async s=>{i.weightPercent=Number(s),await this.plugin.saveSettings(),m()})}).addButton(t=>t.setButtonText("Remove").setWarning().onClick(async()=>{n.components=n.components.filter(s=>s.id!==i.id),await this.plugin.saveSettings(),this.display()})),new o.Setting(e).setName("Allow not inspected/use previous").setDesc("Enable when the component can be marked not inspected and reuse the previous rating.").addToggle(t=>{t.setValue(i.allowNotInspectedUsePrevious).onChange(async s=>{i.allowNotInspectedUsePrevious=s,await this.plugin.saveSettings()})})}renderNonInspectedItemTypes(e){new o.Setting(e).setName("Non-inspected item types").setHeading(),e.createEl("p",{text:"Define navigation or reference items that are not directly inspected."}),new o.Setting(e).setName("Add non-inspected item type").setDesc("Create a new non-inspected point or linear item type.").addButton(n=>{n.setButtonText("Add").onClick(async()=>{this.plugin.settings.nonInspectedItemTypes.push({id:I(),name:"",kind:"point"}),await this.plugin.saveSettings(),this.display()})}),this.plugin.settings.nonInspectedItemTypes.forEach((n,i)=>{this.renderNonInspectedItemType(e,n,i)})}renderNonInspectedItemType(e,n,i){new o.Setting(e).setName(`Non-inspected type ${i+1}`).setHeading(),new o.Setting(e).setName("Type name").setDesc("Use a unique name within non-inspected types.").addText(m=>m.setPlaceholder("Station marker").setValue(n.name).onChange(async a=>{n.name=a,await this.plugin.saveSettings()})),new o.Setting(e).setName("Type kind").setDesc("Point items have a single station. Linear items connect two stations.").addDropdown(m=>{m.addOption("point","Point").addOption("linear","Linear").setValue(n.kind).onChange(async a=>{n.kind=a,await this.plugin.saveSettings(),this.display()})}),new o.Setting(e).setName("Remove non-inspected type").setDesc("Delete this non-inspected item type.").addButton(m=>m.setButtonText("Remove").setWarning().onClick(async()=>{this.plugin.settings.nonInspectedItemTypes=this.plugin.settings.nonInspectedItemTypes.filter(a=>a.id!==n.id),await this.plugin.saveSettings(),this.display()}))}renderCollections(e){new o.Setting(e).setName("Collections").setHeading(),e.createEl("p",{text:"Define each connected linear network (for example, a single canal)."}),e.createEl("p",{text:"Tip: add point items first so linear items can reference start and end stations."}),new o.Setting(e).setName("Add collection").setDesc("Create a named collection of inspected and reference items.").addButton(n=>{n.setButtonText("Add").onClick(async()=>{this.plugin.settings.collections.push({id:I(),name:"",items:[]}),await this.plugin.saveSettings(),this.display()})}),this.plugin.settings.collections.forEach((n,i)=>{this.renderCollection(e,n,i)})}renderCollection(e,n,i){if(new o.Setting(e).setName(`Collection ${i+1}`).setHeading(),new o.Setting(e).setName("Collection name").setDesc("Names are used to group items into connected networks.").addText(m=>m.setPlaceholder("Example canal").setValue(n.name).onChange(async a=>{n.name=a,await this.plugin.saveSettings()})),new o.Setting(e).setName("Remove collection").setDesc("Delete this collection and its items.").addButton(m=>m.setButtonText("Remove").setWarning().onClick(async()=>{this.plugin.settings.collections=this.plugin.settings.collections.filter(a=>a.id!==n.id),await this.plugin.saveSettings(),this.display()})),new o.Setting(e).setName("Add item").setDesc("Add an inspected or reference item to this collection.").addButton(m=>{m.setButtonText("Add").onClick(async()=>{let t=this.getItemTypeSummaries()[0],s=t?t.id:"";n.items.push({id:I(),name:"",typeId:s,station:void 0}),await this.plugin.saveSettings(),this.display()})}),n.items.length===0){e.createEl("p",{text:"No items yet. Add an item to begin describing stations and segments."});return}n.items.forEach((m,a)=>{this.renderCollectionItem(e,n,m,a)})}renderCollectionItem(e,n,i,m){new o.Setting(e).setName(`Item ${m+1}`).setHeading(),new o.Setting(e).setName("Item name").setDesc("Item names must be unique within a collection.").addText(t=>t.setPlaceholder("Reach 1").setValue(i.name).onChange(async s=>{i.name=s,await this.plugin.saveSettings()})),new o.Setting(e).setName("Item type").setDesc("Choose the inspected or non-inspected type for this item.").addDropdown(t=>{var d;let s=this.getItemTypeSummaries();if(s.length===0){t.addOption("","Add item types first"),t.setValue(""),t.setDisabled(!0);return}s.forEach(p=>{t.addOption(p.id,`${p.name||"(unnamed)"} (${p.kind})`)}),t.setValue(i.typeId||((d=s[0])==null?void 0:d.id)||""),t.onChange(async p=>{i.typeId=p;let l=this.getItemKind(p);l==="point"?(i.startStationItemId=void 0,i.endStationItemId=void 0):l==="linear"&&(i.station=void 0),await this.plugin.saveSettings(),this.display()})});let a=this.getItemKind(i.typeId);if(a==="point"&&new o.Setting(e).setName("Station").setDesc("Station value for this point item.").addText(t=>{var s,d;t.setValue((d=(s=i.station)==null?void 0:s.toString())!=null?d:""),t.setPlaceholder("0.0"),t.inputEl.type="number",t.onChange(async p=>{i.station=p===""?void 0:Number(p),await this.plugin.saveSettings()})}),a==="linear"){let t=n.items.filter(d=>this.getItemKind(d.typeId)==="point");e.createEl("p",{text:`Available point items: ${t.length}.`});let s=t.map(d=>({id:d.id,label:`${d.name||"(unnamed)"} ${d.station!==void 0?`@ ${d.station}`:"(no station)"}`}));new o.Setting(e).setName("Start station item").setDesc("Select the point item that defines the start station.").addDropdown(d=>{var p,l;if(s.length===0){d.addOption("","Add a point item first"),d.setValue(""),d.setDisabled(!0);return}s.forEach(g=>d.addOption(g.id,g.label)),d.setValue(i.startStationItemId||((l=(p=s[0])==null?void 0:p.id)!=null?l:"")).onChange(async g=>{i.startStationItemId=g,await this.plugin.saveSettings()})}),new o.Setting(e).setName("End station item").setDesc("Select the point item that defines the end station.").addDropdown(d=>{var p,l;if(s.length===0){d.addOption("","Add a point item first"),d.setValue(""),d.setDisabled(!0);return}s.forEach(g=>d.addOption(g.id,g.label)),d.setValue(i.endStationItemId||((l=(p=s[0])==null?void 0:p.id)!=null?l:"")).onChange(async g=>{i.endStationItemId=g,await this.plugin.saveSettings()})})}new o.Setting(e).setName("Remove item").setDesc("Delete this item from the collection.").addButton(t=>t.setButtonText("Remove").setWarning().onClick(async()=>{n.items=n.items.filter(s=>s.id!==i.id),await this.plugin.saveSettings(),this.display()}))}renderValidation(e){let n=C(this.plugin.settings);if(new o.Setting(e).setName("Validation").setHeading(),e.createEl("p",{text:"Resolve any issues below to keep inspections consistent and connected."}),n.length===0){e.createEl("p",{text:"All settings are valid."});return}let i=e.createEl("ul");n.forEach(m=>{i.createEl("li",{text:m})})}getItemTypeSummaries(){let e=this.plugin.settings.inspectedItemTypes.map(i=>({id:i.id,name:i.name,kind:i.kind})),n=this.plugin.settings.nonInspectedItemTypes.map(i=>({id:i.id,name:i.name,kind:i.kind}));return[...e,...n]}getItemKind(e){let n=this.getItemTypeSummaries().find(i=>i.id===e);return n==null?void 0:n.kind}};var S=class extends k.Plugin{async onload(){await this.loadSettings(),this.addSettingTab(new y(this.app,this))}async loadSettings(){let e=await this.loadData();this.settings={...v,...e}}async saveSettings(){await this.saveData(this.settings)}};
